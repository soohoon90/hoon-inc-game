<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Single Spline</title>
  <link rel="stylesheet" href="svg-generators.css">
</head>

<body>
  <svg id="svg-container" viewBox="0 0 1600 900"></svg>

  <div id="controls">
    Background Color: <br />
    <input type="color" id="bgcolor" value="#BCCCD3" /><br />

    Primary Color: <br />
    <input type="color" id="fgcolor" value="#2196F3" /><br />

    variance: <br />
    <input type="range" id="variance" value="30" min="0" max="100" /><br />

    num_points: <br />
    <input type="range" id="num_points" value="5" min="3" max="12" /><br />
  </div>

  <script>
    const inputs = document.getElementsByTagName("input");
    for (const el of Array.from(inputs)) {
      el.addEventListener("input", generateUsingInput);
    }

    function generateUsingInput() {
      const bg = document.getElementById("bgcolor").value;
      const fg = document.getElementById("fgcolor").value;
      const numPoints = parseInt(document.getElementById("num_points").value);
      const variance = parseInt(document.getElementById("variance").value);

      console.log("generating...");

      createColorfulBlobs("svg-container", bg, fg, numPoints, variance);
    }

    function Dot(x, y, color) {
      const dot = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle"
      );
      dot.setAttribute("cx", x);
      dot.setAttribute("cy", y);
      dot.setAttribute("r", 10);
      dot.setAttribute("fill", color);
      return dot;
    }

    function Line(x1, y1, x2, y2, color) {
      const l = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "line"
      );
      l.setAttribute("x1", x1);
      l.setAttribute("y1", y1);
      l.setAttribute("x2", x2);
      l.setAttribute("y2", y2);
      l.setAttribute("stroke", color);
      return l;
    }

    /*creates formated path string for SVG cubic path element*/
    function Curve(x1, y1, px1, py1, px2, py2, x2, y2) {
      const c = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      );
      const path = `M ${x1} ${y1} C ${px1} ${py1} ${px2} ${py2} ${x2} ${y2}`;
      console.log(path);
      c.setAttribute("d", path);
      c.setAttribute("fill", "none");
      c.setAttribute("stroke", "red");
      c.setAttribute("stroke-width", "6");
      return c;
    }

    function getRandomInt(min, max) {
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function createColorfulBlobs(
      containerId,
      bgColor,
      fgColor,
      numPoints, variance
    ) {
      const container = document.getElementById(containerId);
      var cvb = container.viewBox.baseVal;

      container.innerHTML = "";

      const bgrect = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "rect"
      );
      bgrect.setAttribute("width", cvb.width);
      bgrect.setAttribute("height", cvb.height);
      bgrect.setAttribute("fill", bgColor);
      container.appendChild(bgrect);


      var spacing = cvb.width / (numPoints - 1);

      var points = [];

      // create a list of points at varied heights across
      for (let j = 0; j < numPoints; j++) {

        var plusorminus = Math.random() < 0.5 ? -1 : 1;
        varied_height = cvb.height / 2 - variance * (cvb.height / 2) / 100 * Math.random() * plusorminus;

        let xVal = spacing * j;
        let yVal = varied_height;

        console.log(xVal, yVal);
        container.appendChild(Dot(xVal, yVal, "blue"));
        points.push({ x: xVal, y: yVal });
        // container.appendChild(Dot(xVal, yVal, "red"));
      }

      // primitive lines
      for (let j = 0; j < (points.length - 1); j++) {
        container.appendChild(Line(points[j].x, points[j].y, points[j + 1].x, points[j + 1].y, "grey"));
      }

      // calculate spline beziers control points
      x = new Array();
      y = new Array();
      for (let j = 0; j < (points.length); j++) {
        x[j] = points[j].x;
        y[j] = points[j].y;
      }
      px = computeControlPoints(x);
      py = computeControlPoints(y);

      console.log(x);
      console.log(y);
      console.log(px);
      console.log(py);


      // create beziers curve
      for (let i = 0; i < (points.length - 1); i++) {
        container.appendChild(Curve(x[i], y[i], px.p1[i], py.p1[i], px.p2[i], py.p2[i], x[i + 1], y[i + 1]));
      }

    }

    /*computes control points given knots K, this is the brain of the operation*/
    function computeControlPoints(points) {
      p1 = new Array();
      p2 = new Array();
      n = points.length - 1;

      /*rhs vector*/
      a = new Array();
      b = new Array();
      c = new Array();
      r = new Array();

      /*left most segment*/
      a[0] = 0;
      b[0] = 2;
      c[0] = 1;
      r[0] = points[0] + 2 * points[1];

      /*internal segments*/
      for (i = 1; i < n - 1; i++) {
        a[i] = 1;
        b[i] = 4;
        c[i] = 1;
        r[i] = 4 * points[i] + 2 * points[i + 1];
      }

      /*right segment*/
      a[n - 1] = 2;
      b[n - 1] = 7;
      c[n - 1] = 0;
      r[n - 1] = 8 * points[n - 1] + points[n];

      /*solves Ax=b with the Thomas algorithm (from Wikipedia)*/
      for (i = 1; i < n; i++) {
        m = a[i] / b[i - 1];
        b[i] = b[i] - m * c[i - 1];
        r[i] = r[i] - m * r[i - 1];
      }

      p1[n - 1] = r[n - 1] / b[n - 1];
      for (i = n - 2; i >= 0; --i)
        p1[i] = (r[i] - c[i] * p1[i + 1]) / b[i];

      /*we have p1, now compute p2*/
      for (i = 0; i < n - 1; i++)
        p2[i] = 2 * points[i + 1] - p1[i + 1];

      p2[n - 1] = 0.5 * (points[n] + p1[n - 1]);

      return { p1: p1, p2: p2 };
    }


    // initial render
    generateUsingInput();
  </script>
</body>

</html>